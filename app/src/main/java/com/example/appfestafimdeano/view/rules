RelativeLayout vs LinerLayout

RelativeLayout: escreve por cima tudo nessecitando identificar/informar qual elemento esta relativo a outro.
    >layout_below="@id/..." : informa que o elemento esta below(embaixo) de @id/...
     >layout_alignParentBottom="true" :informa que o elemenento alinhado em seu pai de padrao botao(no roda pé)
     >layout_centerHorizontal="true" :informa que o elemento centralizada horizontalmente(alegoria: duas molas
     laterais em relacao com seu pai)
LinerLayout escreve de forma linear com vetores nessecitando de orientacao e muito conteiner de
LinerLayout para descrever cada parte de celulas
     >android:layout_width="match_parent" + android:gravity="center" = layout_centerHorizontal="true"
----------------------------------------------------------------------------------------------------
PAGINAS NO APP(varias activity)
com.exaple.appfestfimdeano > mause_direito > new > activity
    a ordem de pioridade se da na manifests onde o codigo:
                <intent-filter>
                    <action android:name="android.intent.action.MAIN" />

                    <category android:name="android.intent.category.LAUNCHER" />
                </intent-filter>

    que estiver contatenado com ele sera prioridade de arbertura.
----------------------------------------------------------------------------------------------------
METODO/FUNCAO INTENT(INTENCAO/proposito): usado para dar uma intencao ou um proposito a algo,
no caso uma intencao ao dar um click de abrir outra pagina do app

Intent a = new Intent(2 paremetros);
    1 contexto: o que estar por traz da activity, o que torna essa activity uma classe android
    EX:
        >getApplicationcontext()
        >this
    2 acao: DetailsActivity.class activity que sera aberto sendo referencia class

METODO/FUNCAO startActivity(a): o start usado para iniciar a intencao
----------------------------------------------------------------------------------------------------
SharedPreferences SHERED-PRFERENCES: armazena e reculpera dados pequenos e simples que nao mude com
muita frequencia e de facil acesso no app. para isso e nessesario uma classe objeto propia para abrigar
todas as funcoes e configuracoes do "DB"
1 contrucao da classe :faz a instancia do Shared e faca um construtor para entrada de contexto e saida
de funcoes da classe que vai conter os dados, use contexto como parametro(pq: ) ex:
   //instacia do "BD"
    private SharedPreferences mSharedPreferences;

    //construtor com intuito de iniciar um BD com conteudo(inicar com contexto)
    private SecurityPreferences(Context mcontext) {
        this.mSharedPreferences = mcontext.getSharedPreferences(...);

    1.2:para entrada de contexto ser aceito no Shared:
    mcontext.getSharedPreferences(2paremetros): vai usar o SharedPreferences do contexto de fora da classe
    SecurityPreferences(no caso conxto vem da main );
    getSharedPreferences(2paremetros): metodo que pega uma instancia do SharedPreferences
        >1 nome:o nome que a instancia do SharedPreferences vai ter.
        >2 modo: Context.MODE_... :modificador de acesso dos dados do SharedPreferences fora do app,
        (obs:SO gerencia esse acesso, sendo seguro mediente a esse nivel) as opicoes sao:
            >APPEND:
            >ENABLE_WRITE_AHEAD_LOGGING:
            >MULTI_PROCESS:
            >NO_LOCALIZED_COLLATORS:
            >PRIVATE: ninguem fora do app tem acesso aos dados do SharedPreferences.
            >SERVICE:

2:salvar dados:editando o conteudo do Shared dentro do construtor(pq: o
    nao tem logica em instanciar um "DB" vazio, e mais inteligente exigir os dados ou capturalos para
    edita-lo posteriormente), metodo put(colocar) tem muitas funcoes de por EX:
    this.mSharedPreferences.edit().put... :
        >Int(2parametros)
        >Boolean(2parametros)
        >Float(2parametros)
        >Long(2parametros)
        >String(2parametros)
            1:chave/id
            2:valor
    2.1: no construtor:
    public void stroreString(String key, String value) {
            this.mSharedPreferences.edit().putString(key,value).apply();//.applay: salvar as mudanças
        }
3 retornar os dados:
    public String getStoredString(String key) {
            return this.mSharedPreferences.getString(key, valorInvalido:" ");
        }
----------------------------------------------------------------------------------------------------
DATA:
1 definir a formatcao legivel a usuario com a instancia do SimpleDateFormat:
    private static SimpleDateFormat SIMPLE_DATE_FORMATE = new SimpleDateFormat("dd/MM/yyyy");

2 set as informacaoes o texto do Today com sua devida formatacao(e informacao do dia de hoje em GMT)
        this.mViewHolder.textToday.setText(SIMPLE_DATE_FORMATE.format(Calendar.getInstance().getTime()));

3 com isso falta so informacaes de quantos dias falta para o fim do ano, que consiste em dia hj - dias do
ano ambos em formato int para subtracao(obs type Data, e o que eles soa)
    3.1 crie uma classe para abrigar esses dados e de o valor de hoje

        private Data getDaysLeft() {
            //dia hoje
            Date today = Calendar.getInstance().getTime();

            return today;
        }
    OBS:note que tanto a classe quanto o valor today estao em type Date e ainda com outras informacoes
    nao nessesarias para a equacao. Obrigando a usar o metodo do Calendar.DAY_OF_YEAR que retorna a
    quantidade de dias

    3.2 aqui a começa com a conversao para o int feita segindo a uma incrementacao de instancia de Calendar
    a um nome generico... ao fim, o imprego do uso do metodo Calender.getActualMaximum() que retorna
    o maximo atual de uma propiedade do calendario como o maximo de dias(365 dependendo no ano varia)
    o maximo de horas(24h) etc... sua informacao e tudo atual da hora da sua compilacao.

        private int getDaysLeft() {
            //dia hoje
            Calendar calenderToDays = Calendar.getInstance();
            int today = calenderToDays.get(Calendar.DAY_OF_YEAR);

            //dias total do ano
            Calendar calenderLestDay = Calendar.getInstance();
            int Maxday = calendarLestDay.getActualMaximum(Calendar.DAY_OF_YEAR);

            return Maxday - today;
        }

    3.3 aqui o codigo mais linpo e da maneira que eu faria.

        private int getDaysLeft() {
            //dia hoje
            int today = Calendar.getInstance().get(Calendar.DAY_OF_YEAR);

            //dias total do ano
            int Maxday = Calendar.getInstance().getActualMaximum(Calendar.DAY_OF_YEAR);

            return Maxday - today;
        }

4 instancia da classe getDaysLeft() no main
        //une o valor da classe getDaysLeft() transformado para String(String.valueOf()),

        //e puxa o texto(getString()) que acompanha o valer com res.values.strings.xml para centrarlizar
        //String para mudar futuramente.
        String dia = String.format("%s %s", String.valueOf(this.getDaysLeft()), getString(R.string.Dias));

        //sua atribuicao ao textDaysLaft
        this.mViewHolder.textDaysLaft.setText(dia);